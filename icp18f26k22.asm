MOVLW D'64’ ; number of bytes in erase block MOVWF COUNTER MOVLW BUFFER_ADDR_HIGH ; point to buffer MOVWF FSR0H MOVLW BUFFER_ADDR_LOW MOVWF FSR0L MOVLW CODE_ADDR_UPPER ; Load TBLPTR with the base MOVWF TBLPTRU ; address of the memory block MOVLW CODE_ADDR_HIGH MOVWF TBLPTRH MOVLW CODE_ADDR_LOW MOVWF TBLPTRL READ_BLOCK TBLRD*+ ; read into TABLAT, and inc MOVF TABLAT, W ; get data MOVWF POSTINC0 ; store data DECFSZ COUNTER ; done? BRA READ_BLOCK ; repeat MODIFY_WORD MOVLW BUFFER_ADDR_HIGH ; point to buffer MOVWF FSR0H MOVLW BUFFER_ADDR_LOW MOVWF FSR0L MOVLW NEW_DATA_LOW ; update buffer word MOVWF POSTINC0 MOVLW NEW_DATA_HIGH MOVWF INDF0 ERASE_BLOCK MOVLW CODE_ADDR_UPPER ; load TBLPTR with the base MOVWF TBLPTRU ; address of the memory block MOVLW CODE_ADDR_HIGH MOVWF TBLPTRH MOVLW CODE_ADDR_LOW MOVWF TBLPTRL BSF EECON1, EEPGD ; point to Flash program memory BCF EECON1, CFGS ; access Flash program memory BSF EECON1, WREN ; enable write to memory BSF EECON1, FREE ; enable Erase operation BCF INTCON, GIE ; disable interrupts MOVLW 55h Required MOVWF EECON2 ; write 55h Sequence MOVLW 0AAh MOVWF EECON2 ; write 0AAh BSF EECON1, WR ; start erase (CPU stall) BSF INTCON, GIE ; re-enable interrupts TBLRD*- ; dummy read decrement MOVLW BUFFER_ADDR_HIGH ; point to buffer MOVWF FSR0H MOVLW BUFFER_ADDR_LOW MOVWF FSR0L WRITE_BUFFER_BACK MOVLW BlockSize ; number of bytes in holding register MOVWF COUNTER MOVLW D’64’/BlockSize ; number of write blocks in 64 bytes MOVWF COUNTER2 WRITE_BYTE_TO_HREGS MOVF POSTINC0, W ; get low byte of buffer data MOVWF TABLAT ; present data to table latch TBLWT+* ; write data, perform a short write ; to internal TBLWT holding register.
MOVLW D'64’ ; number of bytes in erase block MOVWF COUNTER MOVLW BUFFER_ADDR_HIGH ; point to buffer MOVWF FSR0H MOVLW BUFFER_ADDR_LOW MOVWF FSR0L MOVLW CODE_ADDR_UPPER ; Load TBLPTR with the base MOVWF TBLPTRU ; address of the memory block MOVLW CODE_ADDR_HIGH MOVWF TBLPTRH MOVLW CODE_ADDR_LOW MOVWF TBLPTRL READ_BLOCK TBLRD*+ ; read into TABLAT, and inc MOVF TABLAT, W ; get data MOVWF POSTINC0 ; store data DECFSZ COUNTER ; done? BRA READ_BLOCK ; repeat MODIFY_WORD MOVLW BUFFER_ADDR_HIGH ; point to buffer MOVWF FSR0H MOVLW BUFFER_ADDR_LOW MOVWF FSR0L MOVLW NEW_DATA_LOW ; update buffer word MOVWF POSTINC0 MOVLW NEW_DATA_HIGH MOVWF INDF0 ERASE_BLOCK MOVLW CODE_ADDR_UPPER ; load TBLPTR with the base MOVWF TBLPTRU ; address of the memory block MOVLW CODE_ADDR_HIGH MOVWF TBLPTRH MOVLW CODE_ADDR_LOW MOVWF TBLPTRL BSF EECON1, EEPGD ; point to Flash program memory BCF EECON1, CFGS ; access Flash program memory BSF EECON1, WREN ; enable write to memory BSF EECON1, FREE ; enable Erase operation BCF INTCON, GIE ; disable interrupts MOVLW 55h Required MOVWF EECON2 ; write 55h Sequence MOVLW 0AAh MOVWF EECON2 ; write 0AAh BSF EECON1, WR ; start erase (CPU stall) BSF INTCON, GIE ; re-enable interrupts TBLRD*- ; dummy read decrement MOVLW BUFFER_ADDR_HIGH ; point to buffer MOVWF FSR0H MOVLW BUFFER_ADDR_LOW MOVWF FSR0L WRITE_BUFFER_BACK MOVLW BlockSize ; number of bytes in holding register MOVWF COUNTER MOVLW D’64’/BlockSize ; number of write blocks in 64 bytes MOVWF COUNTER2 WRITE_BYTE_TO_HREGS MOVF POSTINC0, W ; get low byte of buffer data MOVWF TABLAT ; present data to table latch TBLWT+* ; write data, perform a short write ; to internal TBLWT holding register.
